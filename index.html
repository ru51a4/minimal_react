<head>
    <script src="dombuilder.js"></script>
</head>
<body>

<div class="main">
    <counter></counter>
</div>
</body>

<script>
    var Render;
    var domBuilder = new BuilderDOM();

    class component {

        name = '';

        constructor(_name) {
            this.name = _name;
        }
    }

    class component_counter extends component {
        state = {
            counter: 0,
            counter2: 0,
            visible: true
        };

        body() {
            return `
            <div>
            <div>counter - ${this.state.counter} counter - ${this.state.counter2}</div>
            <div>
            heh kek
            </div>

            <btn></btn>
            <button onclick="runEvent('${this.name}', 'plus')">btn2</button>
            <div r-if="${this.state.visible}">vif</div>
            <button onclick="runEvent('${this.name}', 'toggleDiv')">toggle</button>
            <text></text>
            </div>
        `
        };

        plus() {
            this.state.counter++;
        }

        toggleDiv() {
            this.state.visible = !this.state.visible;
        }
    }

    class component_btn extends component {
        state = {
            kek: 'kek'
        };

        body() {
            return `
                <div>
                <button onclick="runParrentEvent('${this.name}', 'plus')">plus</button>
                <text></text>
                <div>
                ${this.state.kek}dd
                </div>
                <input type="text" onchange="model('${this.name}', {event: event, key: 'kek'})"></input>
                </div>`
        };
    }

    class component_text extends component {
        body() {
            return `<text2></text2>`
        };
    }

    class component_text2 extends component {
        body() {
            return `<div>texdt</div>`
        };
    }


    function runEvent(name, nameEvent, arg) {
        currentComponents.find((item) => {
            item = item.hierarchy.split('.');
            return item[item.length - 1] === name;
        }).component[nameEvent](arg);
        Render.renderDom();
    }

    function runParrentEvent(name, nameEvent) {
        let nameParrent = '';
        currentComponents.forEach((item) => {
            item = item.hierarchy.split('.');
            if (item[item.length - 1] === name) {
                nameParrent = item[item.length - 2];
            }
        });
        runEvent(nameParrent, nameEvent);
    }

    function model(name, {event, key}) {
        const value = event.target.value;
        currentComponents.find((item) => {
            item = item.hierarchy.split('.');
            return item[item.length - 1] === name;
        }).component.state[key] = value;
        //тут трабла, тк инпут перерендаривается и вэлью теряется
        Render.renderDom();
    }

    var components = {};
    var currentComponents = [];

    class render {
        currentDom;
        init = true;
        vdom = [];
        prevVdom = [];

        constructor() {
            components = [
                {
                    name: 'counter',
                    component: component_counter
                },
                {
                    name: 'btn',
                    component: component_btn
                },
                {
                    name: 'text',
                    component: component_text
                },
                {
                    name: 'text2',
                    component: component_text2
                }
            ];
            this.currentDom = document.querySelector('.main').innerHTML.trim().split("\n");
        }

        renderDom() {
            var currentDom = '';
            let counter = 0;

            this.currentDom.forEach((tag) => {
                //deep
                var hierarchyStack = [];

                function deep(tag) {
                    const tagName = this.utils.getTag(tag);
                    if (!this.utils.isComponent(tagName)) {
                        currentDom += tag + "\n";
                    } else {
                        const currentName = `${tagName}-${counter++}`;
                        let component = currentComponents.find(item => item.name === currentName);
                        hierarchyStack.push(currentName);
                        if (!component) {
                            let currentComponent = components.find((item) => item.name === tagName).component;
                            component = new currentComponent(currentName);
                            currentComponents.push({
                                name: currentName,
                                component: component,
                                hierarchy: hierarchyStack.join('.')
                            });
                        } else {
                            component = component.component;
                        }
                        let currentComponentDom = component.body();
                        currentComponentDom.split("\n").forEach((tag) => {
                            deep.bind(this, tag)();
                        });
                        hierarchyStack.pop(currentName);
                    }
                }

                deep.bind(this, tag)();
                //
            });

            //todo dom
            if (!this.init) {
                function getDomEl(virtualDomStack) {
                    let currentDocumentDom = document.querySelector('.main');

                    for (let i = 1; i <= virtualDomStack.length - 1; i++) {
                        let numChild = this.vdom.find(el => el.id == virtualDomStack[i]).numChild;
                        if (currentDocumentDom.children[numChild]) {
                            currentDocumentDom = currentDocumentDom.children[numChild];
                        }
                    }
                    return currentDocumentDom;
                }

                var stackUpdateDom = [];
                this.vdom = domBuilder.build(currentDom);

                function deepReplace(index) {
                    let elVdom = this.vdom[index];
                    let prevElVdom = this.prevVdom[index];
                    if (elVdom.innerTEXT !== prevElVdom.innerTEXT) {
                        stackUpdateDom.push({el: elVdom, event: 'innerTEXT'});
                    }
                    if (!elVdom.visible) {
                        stackUpdateDom.push({el: elVdom, event: 'delete'});
                    }
                    if (elVdom.visible && !prevElVdom.visible) {
                        stackUpdateDom.push({el: elVdom, event: 'create'});
                    }
                    elVdom.childrens.forEach((childId) => {
                        var domElIndex;
                        this.vdom.forEach((item, elIndex) => {
                            if (item.id === childId) {
                                domElIndex = elIndex;
                            }
                        });
                        deepReplace.bind(this, domElIndex)();
                    })
                }

                deepReplace.bind(this, 1)();
                stackUpdateDom.forEach((itemUpdate) => {
                    let domEl = getDomEl.bind(this, [...itemUpdate.el.parrent, itemUpdate.el.id])();
                    switch (itemUpdate.event) {
                        case "delete":
                            domEl.remove();
                            break;
                        case "create":
                            domEl = getDomEl.bind(this, [...itemUpdate.el.parrent])();
                            let html = '';
                        function sumHtml(index, init = false) {
                            const el = this.vdom.find(el => el.id === index);
                            if(!init){
                                html += el.tag + el.innerTEXT;
                            }
                            this.vdom.find(el => el.id === index).childrens.forEach((childId) => {
                                sumHtml.bind(this, childId)();
                            });
                            if(!init){
                                html += el.closedtag;
                            }
                        }

                            let parrentId = this.vdom.find(el => el.id === itemUpdate.el.parrent[itemUpdate.el.parrent.length - 1]).id;
                            sumHtml.bind(this, parrentId, true)();
                            domEl.innerHTML = html;
                            break;
                        case "innerTEXT":
                            domEl.innerText = itemUpdate.el.innerTEXT;
                            break;
                    }
                });
                this.prevVdom = this.vdom;
            } else {
                document.querySelector('.main').innerHTML = currentDom;
                this.init = false;
                this.prevVdom = domBuilder.build(currentDom);
            }
            ////////////
        }

        utils = {
            isComponent(tag) {
                return components.map(item => item.name).includes(tag);
            },
            getTag(str) {
                return str.split("</")[0].replace("<", "").replace(">", "").trim();
            }
        };
    }

    Render = new render();

    function main() {
        Render.renderDom();
    }

    main();

</script>

